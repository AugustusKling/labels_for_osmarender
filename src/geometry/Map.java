package geometry;

import genetic.LabeledGenome;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Iterator;

import javax.swing.JFrame;
import javax.xml.namespace.NamespaceContext;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.apache.batik.bridge.BridgeContext;
import org.apache.batik.bridge.DocumentLoader;
import org.apache.batik.bridge.GVTBuilder;
import org.apache.batik.bridge.UserAgent;
import org.apache.batik.bridge.UserAgentAdapter;
import org.apache.batik.dom.svg.SAXSVGDocumentFactory;
import org.apache.batik.dom.svg.SVGOMPathElement;
import org.apache.batik.dom.svg.SVGOMTextElement;
import org.apache.batik.svggen.SVGGraphics2D;
import org.apache.batik.swing.JSVGCanvas;
import org.apache.batik.util.XMLResourceDescriptor;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.PrefixResolverDefault;
import org.w3c.dom.DOMException;
import org.w3c.dom.NodeList;
import org.w3c.dom.svg.SVGCircleElement;
import org.w3c.dom.svg.SVGDocument;

import utilities.Logger;

import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.MultiPolygon;

/**
 * Container for a map
 * 
 * TODO Still contains some fixed XPaths from testing that need to be adapted to map rule file
 */
public class Map {
	private SVGDocument doc;
	private XPath xpath;
	private Geometry avoids = new MultiPolygon(null, new GeometryFactory());
	private LabeledGenome<LabelGene> baseGenome = new LabeledGenome<LabelGene>(avoids);
	private LabeledGenome<LabelGene> bestVariation;
	
	public Map(){
	}

	/**
	 * Adds a point like feature to map
	 * @param graphic DOM node that represents the feature
	 * @throws DOMException 
	 * @throws XPathExpressionException 
	 */
	public void addPointObject(SVGCircleElement graphic) throws XPathExpressionException, DOMException {
		String osmNamespace = xpath.getNamespaceContext().getNamespaceURI("osm");
		SVGOMTextElement text = (SVGOMTextElement) xpath.evaluate("//svg:g[@id='map']/svg:text[(@k='species' or contains(@class, 'caption-core') or contains(@class, 'caption')) and @osm:id='"+graphic.getAttributeNS(osmNamespace, "id")+"']", doc, XPathConstants.NODE);
		LabeledPointGene gene = new LabeledPointGene(graphic, text);
		if (gene.isFeasiblePositionAvailable(avoids)) {
			baseGenome.add(gene);
		} else {
			gene.discard();
		}
	}

	/**
	 * Loads an input file (SVG generated by modified Osmarender)
	 * @param uri Location of file
	 * @throws IOException
	 */
	public void load(String uri) throws IOException {
		String parser = XMLResourceDescriptor.getXMLParserClassName();
		SAXSVGDocumentFactory f = new SAXSVGDocumentFactory(parser);
		doc = (SVGDocument) f.createDocument(uri);
		System.out.println("File read");
		UserAgent userAgent = new UserAgentAdapter();
		DocumentLoader loader = new DocumentLoader(userAgent);
		BridgeContext ctx = new BridgeContext(userAgent, loader);
		ctx.setDynamicState(BridgeContext.DYNAMIC);
		GVTBuilder builder = new GVTBuilder();
		builder.build(ctx, doc);

		xpath = XPathFactory.newInstance().newXPath();
		final PrefixResolver resolver = new PrefixResolverDefault(doc
				.getDocumentElement());
		xpath.setNamespaceContext(new NamespaceContext() {

			@Override
			public Iterator<Object> getPrefixes(String namespaceURI) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getPrefix(String namespaceURI) {
				// TODO Auto-generated method stub
				return null;
			}

			@Override
			public String getNamespaceURI(String prefix) {
				return resolver.getNamespaceForPrefix(prefix);
			}
		});
	}

	/**
	 * Retrieves some nodes from the input file
	 * @param xPath
	 * @return List of DOM elements
	 * @throws XPathExpressionException
	 */
	public NodeList getNodes(String xPath) throws XPathExpressionException {
		NodeList symbols = (NodeList) xpath.evaluate(xPath, doc,
				XPathConstants.NODESET);
		return symbols;
	}

	/**
	 * Saves the map
	 * @param file Filename to use
	 * @throws IOException If location is not writable
	 */
	public void save(String file) throws IOException {
		SVGGraphics2D generator = new SVGGraphics2D(doc);
		File outfile = new File(file);
		if (!outfile.exists()) {
			outfile.createNewFile();
		}
		Writer out = new OutputStreamWriter(new FileOutputStream(outfile),
				"UTF-8");
		generator.stream(doc.getDocumentElement(), out);
		System.out.println("Map saved");
	}

	/**
	 * Displays the map on the screen
	 */
	public void show() {
		JFrame frame = new JFrame("SVGView");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		JSVGCanvas svg = new JSVGCanvas();
		svg.setDocument(doc);
		frame.getContentPane().add(svg);
		frame.pack();
		frame.setVisible(true);
		frame
				.setExtendedState(frame.getExtendedState()
						| JFrame.MAXIMIZED_BOTH);
	}

	/**
	 * Clears the genome and leaves the labels at the current positions
	 * 
	 * Useful if positions of more important objects should be calculated before
	 * calculation of less important objects is due.
	 */
	public void fixObjects() {
		baseGenome = bestVariation;
		bestVariation = null;
		for (LabelGene gene : baseGenome) {
			avoids = avoids.union(gene.getGeometry());
			gene.render();
		}
		baseGenome = new LabeledGenome<LabelGene>(avoids);
	}

	/**
	 * Calculates the total overlapping area in the map
	 * 
	 * @return Area of overlap
	 */
	public double getTotalOverlaps() {
		return baseGenome.getTotalOverlaps();
	}

	/**
	 * Mutates all genes representing overlapping labels
	 */
	public void mutate() {
		if(bestVariation==null || baseGenome.getTotalOverlaps()<bestVariation.getTotalOverlaps()){
			Logger.log("Found new best "+baseGenome.getTotalOverlaps());
			bestVariation = baseGenome.clone();
		}
		//double quality = baseGenome.getTotalOverlaps();
		baseGenome.mutate();
		// Only accept mutations if total quality does not decrease by more than 10%
		/*if(baseGenome.getTotalOverlaps()>quality*1.1){
			baseGenome = bestVariation;
			this.bestVariation = baseGenome.clone();
		}*/
	}

	/**
	 * Removes some labels from the map
	 * 
	 * @param amount
	 *            Number of labels to remove
	 */
	public void discard(int amount) {
		if(bestVariation!=null && bestVariation.getTotalOverlaps()<baseGenome.getTotalOverlaps()){
			// Reverting
			baseGenome = bestVariation;
		}
		baseGenome.discard(amount);
		this.bestVariation = baseGenome.clone();
	}

	public void addAreaObject(SVGOMPathElement graphic) throws XPathExpressionException, DOMException {
		String osmNamespace = xpath.getNamespaceContext().getNamespaceURI("osm");
		SVGOMTextElement text = (SVGOMTextElement) xpath.evaluate("//svg:g[@id='map']/svg:text[@osm:id='"+graphic.getAttributeNS(osmNamespace, "id")+"']", doc, XPathConstants.NODE);
		if(text==null){
			System.err.println("Ignoring data for "+graphic.getAttributeNS(osmNamespace, "id")+" since text is empty");
			return;
		}
		if(graphic.getAttribute("d").isEmpty()){
			System.err.println("Wrong data for "+graphic.getAttributeNS(osmNamespace, "id"));
			text.getParentNode().removeChild(text);
			return;
		}
		LabelGene gene = new LabeledAreaGene(graphic, text);
		if (gene.isFeasiblePositionAvailable(avoids)) {
			baseGenome.add(gene);
		} else {
			gene.discard();
		}
	}

	public void addLineObject(SVGOMTextElement graphic) {
		LabelGene gene = new LabeledLineGene(graphic);
		if (gene.isFeasiblePositionAvailable(avoids)) {
			baseGenome.add(gene);
		}
	}

	public void initializePopulation() {
		System.out.println("Base genome initialized");
	}

}
